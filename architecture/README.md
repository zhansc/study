# 代码

写代码的目标就是将重复工作变成可复用的方案

> 重复
1. 业务上的重复场景
2. 技术上重复的代码

> 重构

在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构

> 重构的原因
- 需求变化
需求的变化使重构变得必要。如果一段代码能正常工作，并且不会再被修改，那么完全可以不去重构它。

- 新需求（预备性重构）
重构的最佳时机在添加新功能之前，在动手添加新功能之前，看看现有的代码库，此时经常会发现：如果对代码结构做一点微调，工作会变的容易很多（旧代码重构来扩展新功能）

- 帮助理解的重构
需要先理解代码在做什么，然后才能着手修改。一旦需要思考“这段代码到底在做什么”，就会自问：能不能重构这段代码，令其一目了然？
可能看见了一段结构糟糕的条件逻辑，也可能希望复用一个函数，但花费了几分钟才弄懂它到底在做什么，因为它的函数命名实在是太糟糕了。这些都是重构的机会。

- 捡垃圾式重构
当在重构过程中或者开发过程中，发现某一块不好，如果很容易修改可以顺手修改，但如果很麻烦，又有紧急事情时候，可以选择记录下来。
就像野营者的老话：至少让营地比你到达时更干净，久而久之，营地就非常干净（来自营地法则）

- 见机行事的重构
重构经常发生在日常开发中，随手可改的地方。当发现不好的味道，就要将它重构。

- 长期的重构
可以在一个团队内，达成共识。当大家遇到时候，就改正它例如，如果想替换一个正在使用的库，可以先引入一层新的抽象，使其兼容新旧两个库的接口，
然后一旦调用方完全改为了使用这层抽象，替换下面的库就会如容易的多。

- 复审代码（code review）时的重构
开发者与审查者保持持续沟通，使得审查者能够深入了解逻辑，使得开发者能充分认同复审者的修改意见（结对编程）


> 代码
- 第一阶段：基本完成需求功能。可能存在一些隐藏bug，不规范，不可重用
- 第二阶段：清晰的代码。对上一版本进行代码规范优化
- 第三阶段：代码映射需求（单一职责原则）。存在一些过早优化导致代码含义不清晰的情况，例如一个方法/代码块做了多件事情，实现了多个需求功能，
可能是相互独立的，后续变化是相互独立可能行性也很大，代码改动的影响面就扩大了，且不了解背景的系统维护者，不敢轻易拆分、变动。当系统规模越大，
这种和需求不是一一对应的代码越让维护者手足无措。需求改动很小而代码却牵一发动全身，根源往往就是过早优化。“优化”和“通用”往往是对立的，
优化的越彻底就与业务场景结合越紧密，通用性也越差，适用面越窄。
- 第四阶段：对象抽象，高内聚低耦合


编码规范
统一规范，才能清晰
代码重构的顺序，元素从小到大


# 框架

# 架构

